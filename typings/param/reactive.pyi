"""
This type stub file was generated by pyright.
"""

from typing import Any, Callable, Optional
from .parameterized import Parameterized

"""
reactive API

`rx` is a wrapper around a Python object that lets users create
reactive expression pipelines by calling existing APIs on an object with dynamic
parameters or widgets.

An `rx` instance watches what operations are applied to the object
and records these on each instance, which are then strung together
into a chain.

The original input to an `rx` object is stored in a mutable list and can be
accessed via the `_obj` property. The shared mutable data structure
ensures that all `rx` instances created from the same object can
hold a shared reference that can be updated, e.g. via the `.value`
property or because the input was itself a reference to some object that
can potentially be updated.

When an operation is applied to an `rx` instance, it will
record the operation and create a new instance using the `_clone` method,
e.g. `dfi.head()` first records that the `'head'` attribute is
accessed, which is achieved by overriding `__getattribute__`. A new
reactive object is returned, which will then record that it is
being called, and that new object will be itself called, as
`rx` implements `__call__`. `__call__` returns another
`rx` instance. To be able to watch all the potential
operations that may be applied to an object, `rx` implements:

- `__getattribute__`: Watching for attribute accesses
- `__call__`: Intercepting both actual calls or method calls if an
  attribute was previously accessed
- `__getitem__`: Intercepting indexing operations
- Operators: Implementing all valid operators `__gt__`, `__add__`, etc.
- `__array_ufunc__`: Intercepting numpy universal function calls

The `rx` object evaluates operations lazily, but whenever the
current value is needed the operations are automatically
evaluated. Note that even attribute access or tab-completion
operations can result in evaluation of the pipeline. This is very
useful in a REPL, as this allows inspecting the transformed
object at any point of the pipeline, and as such provide correct
auto-completion and docstrings. E.g. executing `dfi.A.max?` in an
interactive REPL or notebook where it allows returning the docstring
of the method being accessed.

The actual operations are stored as a dictionary on the `_operation`
attribute of each instance. They contain 4 keys:

- `fn`: The function to apply (either an actual function or a string
        indicating the operation is a method on the object)
- `args`: Any arguments to supply to the `fn`.
- `kwargs`: Any keyword arguments to supply to the `fn`.
- `reverse`: If the function is not a method this indicates whether
             the first arg and the input object should be supplied in
             reverse order.

The `_depth` attribute starts at 0 and is incremented by 1 every time
a new `rx` instance is created part of a chain. The root
instance in a reactive expression  has a `_depth` of 0. A reactive
expression can consist of multiple chains, such as `dfi[dfi.A > 1]`,
as the `rx` instance is referenced twice in the expression. As a
consequence `_depth` is not the total count of `rx` instance
creations of a pipeline, it is the count of instances created in the
outer chain. In the example, that would be `dfi[]`. Each `rx`
instance keeps a reference to the previous instance in the chain and
each instance tracks whether its current value is up-to-date via the
`_dirty` attribute, which is set to False if any dependency changes.

The `_method` attribute is a string that temporarily stores the
method/attr accessed on the object, e.g. `_method` is 'head' in
`dfi.head()`, until the `rx` instance created in the pipeline
is called at which point `_method` is reset to None. In cases such as
`dfi.head` or `dfi.A`, `_method` is not (yet) reset to None. At this
stage the `rx` instance returned has its `_current` attribute
not updated, e.g. `dfi.A._current` is still the original dataframe,
not the 'A' series. Keeping `_method` is thus useful for instance to
display `dfi.A`, as the evaluation of the object will check whether
`_method` is set or not, and if it's set it will use it to compute the
object returned, e.g. the series `df.A` or the method `df.head`, and
display its repr.
"""
class Wrapper(Parameterized):
    """Helper class to allow updating literal values easily."""
    object = ...


class GenWrapper(Parameterized):
    """Helper class to allow streaming from generator functions."""
    object = ...


class Trigger(Parameterized):
    """Helper class to allow triggering an event under some condition."""
    value = ...
    def __init__(self, parameters=..., internal=..., **params) -> None:
        ...
    


class Resolver(Parameterized):
    """Helper class to allow (recursively) resolving references."""
    object = ...
    recursive = ...
    value = ...
    def __init__(self, **params) -> None:
        ...
    


class NestedResolver(Resolver):
    object = ...


class reactive_ops:
    """
    The reactive namespace.

    Provides reactive versions of operations that cannot be made reactive through operator overloading, such as
    `.rx.and_` and `.rx.bool`. Calling this namespace (`()`) returns a reactive expression.

    Returns
    -------
    Reactive expression
        The result of calling the reactive namespace is a reactive expression.

    User Guide
    ----------
    https://param.holoviz.org/user_guide/Reactive_Expressions.html#special-methods-on-rx

    Examples
    --------
    Create a Parameterized instance:

    >>> import param
    >>> class P(param.Parameterized):
    ...     a = param.Number()
    >>> p = P(a=1)

    Get the current value:

    >>> a = p.param.a.rx.value

    Call it to get a reactive expression:

    >>> rx_value = p.param.a.rx()

    """
    def __init__(self, reactive) -> None:
        ...
    
    def __call__(self): # -> Any | rx:
        """Creates a reactive expression."""
        ...
    
    def and_(self, other): # -> rx:
        """Replacement for the ``and`` statement."""
        ...
    
    def bool(self): # -> rx:
        """__bool__ cannot be implemented so it is provided as a method."""
        ...
    
    def buffer(self, n): # -> rx:
        """Collects the last n items that were emitted."""
        ...
    
    def in_(self, other): # -> rx:
        """Replacement for the ``in`` statement."""
        ...
    
    def is_(self, other): # -> rx:
        """Replacement for the ``is`` statement."""
        ...
    
    def is_not(self, other): # -> rx:
        """Replacement for the ``is not`` statement."""
        ...
    
    def len(self): # -> rx:
        """__len__ cannot be implemented so it is provided as a method."""
        ...
    
    def map(self, func, /, *args, **kwargs): # -> rx:
        """
        Apply a function to each item.

        Arguments:
        ---------
        func: function
          Function to apply.
        args: iterable, optional
          Positional arguments to pass to `func`.
        kwargs: mapping, optional
          A dictionary of keywords to pass to `func`.

        """
        ...
    
    def not_(self): # -> rx:
        """__bool__ cannot be implemented so not has to be provided as a method."""
        ...
    
    def or_(self, other): # -> rx:
        """Replacement for the ``or`` statement."""
        ...
    
    def pipe(self, func, /, *args, **kwargs): # -> rx:
        """
        Apply chainable functions.

        Arguments:
        ---------
        func: function
          Function to apply.
        args: iterable, optional
          Positional arguments to pass to `func`.
        kwargs: mapping, optional
          A dictionary of keywords to pass to `func`.

        """
        ...
    
    def resolve(self, nested=..., recursive=...):
        """
        Resolves references held by the expression.

        As an example if the expression returns a list of parameters
        this operation will return a list of the parameter values.

        Arguments:
        ---------
        nested: bool
          Whether to resolve references contained within nested objects,
          i.e. tuples, lists, sets and dictionaries.
        recursive: bool
          Whether to recursively resolve references, i.e. if a reference
          itself returns a reference we recurse into it until no more
          references can be resolved.

        """
        ...
    
    def updating(self):
        """Returns a new expression that is True while the expression is updating."""
        ...
    
    def when(self, *dependencies, initial=...): # -> Any:
        """
        Returns a reactive expression that emits the contents of this
        expression only when the dependencies change. If initial value
        is provided and the dependencies are all param.Event types the
        expression will not be evaluated until the first event is
        triggered.

        Arguments:
        ---------
        dependencies: param.Parameter | rx
          A dependency that will trigger an update in the output.
        initial: object
          Object that will stand in for the actual value until the
          first time a param.Event in the dependencies is triggered.

        """
        ...
    
    def where(self, x, y): # -> Callable[..., Generator[Any, Any, None]] | Callable[..., AsyncGenerator[Any, Any]] | DependsFunc[Callable[..., CoroutineType[Any, Any, Any]]] | DependsFunc[Callable[..., object | Any]]:
        """
        Returns either x or y depending on the current state of the
        expression, i.e. replaces a ternary if statement.

        Arguments:
        ---------
        x: object
          The value to return if the expression evaluates to True.
        y: object
          The value to return if the expression evaluates to False.

        """
        ...
    
    @property
    def value(self): # -> _Undefined | Any | type[Skip] | None:
        """
        Returns the current state of the reactive expression by
        evaluating the pipeline.
        """
        ...
    
    @value.setter
    def value(self, new): # -> None:
        """Allows overriding the original input to the pipeline."""
        ...
    
    def watch(self, fn=..., onlychanged=..., queued=..., precedence=...): # -> None:
        """
        Adds a callable that observes the output of the pipeline.
        If no callable is provided this simply causes the expression
        to be eagerly evaluated.
        """
        ...
    


def bind(function, *args, watch=..., **kwargs): # -> Callable[..., Generator[Any, Any, None]] | Callable[..., AsyncGenerator[Any, Any]] | DependsFunc[Callable[..., CoroutineType[Any, Any, Any]]] | DependsFunc[Callable[..., object | Any]]:
    """
    Given a function, returns a wrapper function that binds the values
    of some or all arguments to Parameter values and expresses Param
    dependencies on those values, so that the function can be invoked
    whenever the underlying values change and the output will reflect
    those updated values.

    As for functools.partial, arguments can also be bound to constants,
    which allows all of the arguments to be bound, leaving a simple
    callable object.

    Arguments:
    ---------
    function: callable
        The function to bind constant or dynamic args and kwargs to.
    args: object, param.Parameter
        Positional arguments to bind to the function.
    watch: boolean
        Whether to evaluate the function automatically whenever one of
        the bound parameters changes.
    kwargs: object, param.Parameter
        Keyword arguments to bind to the function.

    Returns
    -------
    Returns a new function with the args and kwargs bound to it and
    annotated with all dependencies.

    """
    ...

class rx:
    """
    `rx` allows wrapping objects and then operating on them
    interactively while recording any operations applied to them. By
    recording all arguments or operands in the operations the recorded
    pipeline can be replayed if an operand represents a dynamic value.

    Parameters
    ----------
    obj: any
        A supported data structure object

    Examples
    --------
    Instantiate it from an object:

    >>> ifloat = rx(3.14)
    >>> ifloat * 2
    6.28

    Then update the original value and see the new result:
    >>> ifloat.value = 1
    2

    """
    _accessors: dict[str, Callable[[rx], Any]] = ...
    _display_options: tuple[str] = ...
    _display_handlers: dict[type, tuple[Any, dict[str, Any]]] = ...
    _method_handlers: dict[str, Callable] = ...
    @classmethod
    def register_accessor(cls, name: str, accessor: Callable[[rx], Any], predicate: Optional[Callable[[Any], bool]] = ...): # -> None:
        """
        Registers an accessor that extends rx with custom behavior.

        Arguments:
        ---------
        name: str
          The name of the accessor will be attribute-accessible under.
        accessor: Callable[[rx], any]
          A callable that will return the accessor namespace object
          given the rx object it is registered on.
        predicate: Callable[[Any], bool] | None

        """
        ...
    
    @classmethod
    def register_display_handler(cls, obj_type, handler, **kwargs): # -> None:
        """
        Registers a display handler for a specific type of object,
        making it possible to define custom display options for
        specific objects.

        Arguments:
        ---------
        obj_type: type | callable
          The type to register a custom display handler on.
        handler: Viewable | callable
          A Viewable or callable that is given the object to be displayed
          and the custom keyword arguments.
        kwargs: dict[str, Any]
          Additional display options to register for this type.

        """
        ...
    
    @classmethod
    def register_method_handler(cls, method, handler): # -> None:
        """
        Registers a handler that is called when a specific method on
        an object is called.
        """
        ...
    
    def __new__(cls, obj=..., **kwargs): # -> Self:
        ...
    
    def __init__(self, obj=..., operation=..., fn=..., depth=..., method=..., prev=..., _shared_obj=..., _current=..., _wrapper=..., **kwargs) -> None:
        ...
    
    @property
    def rx(self) -> reactive_ops:
        """
        The reactive namespace.

        Provides reactive versions of operations that cannot be made reactive through operator overloading, such as
        `.rx.and_` and `.rx.bool`. Calling this namespace (`()`) returns a reactive expression.

        Returns
        -------
        Reactive expression
            The result of calling the reactive namespace is a reactive expression.

        User Guide
        ----------
        https://param.holoviz.org/user_guide/Reactive_Expressions.html#special-methods-on-rx

        Examples
        --------
        Create a Parameterized instance:

        >>> import param
        >>> class P(param.Parameterized):
        ...     a = param.Number()
        >>> p = P(a=1)

        Get the current value:

        >>> a = p.param.a.rx.value

        Call it to get a reactive expression:

        >>> rx_value = p.param.a.rx()

        """
        ...
    
    def __dir__(self): # -> list[str]:
        ...
    
    def __getattribute__(self, name): # -> Any | Self:
        ...
    
    def __call__(self, *args, **kwargs): # -> Any | Self:
        ...
    
    def __array_ufunc__(self, ufunc, method, *args, **kwargs): # -> Self:
        ...
    
    def __abs__(self): # -> Self:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __round__(self, ndigits=...): # -> Self:
        ...
    
    def __ceil__(self): # -> Self:
        ...
    
    def __floor__(self): # -> Self:
        ...
    
    def __invert__(self): # -> Self:
        ...
    
    def __neg__(self): # -> Self:
        ...
    
    def __pos__(self): # -> Self:
        ...
    
    def __trunc__(self): # -> Self:
        ...
    
    def __add__(self, other): # -> Self:
        ...
    
    def __and__(self, other): # -> Self:
        ...
    
    def __divmod__(self, other): # -> Self:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __floordiv__(self, other): # -> Self:
        ...
    
    def __ge__(self, other) -> bool:
        ...
    
    def __gt__(self, other) -> bool:
        ...
    
    def __le__(self, other) -> bool:
        ...
    
    def __lt__(self, other) -> bool:
        ...
    
    def __lshift__(self, other): # -> Self:
        ...
    
    def __matmul__(self, other): # -> Self:
        ...
    
    def __mod__(self, other): # -> Self:
        ...
    
    def __mul__(self, other): # -> Self:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    
    def __or__(self, other): # -> Self:
        ...
    
    def __rshift__(self, other): # -> Self:
        ...
    
    def __pow__(self, other): # -> Self:
        ...
    
    def __sub__(self, other): # -> Self:
        ...
    
    def __truediv__(self, other): # -> Self:
        ...
    
    def __xor__(self, other): # -> Self:
        ...
    
    def __radd__(self, other): # -> Self:
        ...
    
    def __rand__(self, other): # -> Self:
        ...
    
    def __rdiv__(self, other): # -> Self:
        ...
    
    def __rdivmod__(self, other): # -> Self:
        ...
    
    def __rfloordiv__(self, other): # -> Self:
        ...
    
    def __rlshift__(self, other): # -> Self:
        ...
    
    def __rmod__(self, other): # -> Self:
        ...
    
    def __rmul__(self, other): # -> Self:
        ...
    
    def __ror__(self, other): # -> Self:
        ...
    
    def __rpow__(self, other): # -> Self:
        ...
    
    def __rrshift__(self, other): # -> Self:
        ...
    
    def __rsub__(self, other): # -> Self:
        ...
    
    def __rtruediv__(self, other): # -> Self:
        ...
    
    def __rxor__(self, other): # -> Self:
        ...
    
    def __getitem__(self, other): # -> Self:
        ...
    
    def __iter__(self): # -> Generator[Self, Any, None]:
        ...
    


