"""
This type stub file was generated by pyright.
"""

import typing
from .parameterized import Parameter, Parameterized, ParameterizedFunction, instance_descriptor
from ._utils import ParamFutureWarning as _ParamFutureWarning, _deprecate_positional_args, _deprecated

"""
Parameters are a kind of class attribute allowing special behavior,
including dynamically generated parameter values, documentation
strings, constant and read-only parameters, and type or range checking
at assignment time.

Potentially useful for any large Python program that needs
user-modifiable object attributes; see the Parameter and Parameterized
classes for more information.  If you do not want to add a dependency
on external code by importing from a separately installed param
package, you can simply save this file as param.py and copy it and
parameterized.py directly into your own package.

This file contains subclasses of Parameter, implementing specific
parameter types (e.g. Number), and also imports the definition of
Parameters and Parameterized classes.
"""
def param_union(*parameterizeds, warn=...): # -> dict[Any, Any]:
    """
    Given a set of Parameterized objects, returns a dictionary
    with the union of all param name,value pairs across them.

    Parameters
    ----------
    warn : bool, optional
        Wether to warn if the same parameter have been given multiple values,
        otherwise use the last value, by default True

    Returns
    -------
    dict
        Union of all param name,value pairs

    """
    ...

def guess_param_types(**kwargs): # -> dict[Any, Any]:
    """
    Given a set of keyword literals, promote to the appropriate
    parameter type based on some simple heuristics.
    """
    ...

def parameterized_class(name, params, bases=...): # -> Any:
    """
    Dynamically create a parameterized class with the given name and the
    supplied parameters, inheriting from the specified base(s).
    """
    ...

def guess_bounds(params, **overrides): # -> dict[Any, Any]:
    """
    Given a dictionary of Parameter instances, return a corresponding
    set of copies with the bounds appropriately set.


    If given a set of override keywords, use those numeric tuple bounds.
    """
    ...

def get_soft_bounds(bounds, softbounds): # -> tuple[Any | None, Any | None]:
    """
    For each soft bound (upper and lower), if there is a defined bound
    (not equal to None) and does not exceed the hard bound, then it is
    returned. Otherwise it defaults to the hard bound. The hard bound
    could still be None.
    """
    ...

class Infinity:
    """
    An instance of this class represents an infinite value. Unlike
    Python's float('inf') value, this object can be safely compared
    with gmpy numeric types across different gmpy versions.

    All operators on Infinity() return Infinity(), apart from the
    comparison and equality operators. Equality works by checking
    whether the two objects are both instances of this class.
    """
    def __eq__(self, other) -> bool:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    
    def __lt__(self, other) -> bool:
        ...
    
    def __le__(self, other) -> bool:
        ...
    
    def __gt__(self, other) -> bool:
        ...
    
    def __ge__(self, other) -> bool:
        ...
    
    def __add__(self, other): # -> Self:
        ...
    
    def __radd__(self, other): # -> Self:
        ...
    
    def __ladd__(self, other): # -> Self:
        ...
    
    def __sub__(self, other): # -> Self:
        ...
    
    def __iadd__(self, other): # -> Self:
        ...
    
    def __isub__(self, other): # -> Self:
        ...
    
    def __repr__(self): # -> Literal['Infinity()']:
        ...
    
    def __str__(self) -> str:
        ...
    


class Time(Parameterized):
    """
    A callable object returning a number for the current time.

    Here 'time' is an abstract concept that can be interpreted in any
    useful way.  For instance, in a simulation, it would be the
    current simulation time, while in a turn-taking game it could be
    the number of moves so far.  The key intended usage is to allow
    independent Parameterized objects with Dynamic parameters to
    remain consistent with a global reference.

    The time datatype (time_type) is configurable, but should
    typically be an exact numeric type like an integer or a rational,
    so that small floating-point errors do not accumulate as time is
    incremented repeatedly.

    When used as a context manager using the 'with' statement
    (implemented by the __enter__ and __exit__ special methods), entry
    into a context pushes the state of the Time object, allowing the
    effect of changes to the time value to be explored by setting,
    incrementing or decrementing time as desired. This allows the
    state of time-dependent objects to be modified temporarily as a
    function of time, within the context's block. For instance, you
    could use the context manager to "see into the future" to collect
    data over multiple times, without affecting the global time state
    once exiting the context. Of course, you need to be careful not to
    do anything while in context that would affect the lasting state
    of your other objects, if you want things to return to their
    starting state when exiting the context.

    The starting time value of a new Time object is 0, converted to
    the chosen time type. Here is an illustration of how time can be
    manipulated using a Time object:

    >>> time = Time(until=20, timestep=1)
    >>> 'The initial time is %s' % time()
    'The initial time is 0'
    >>> 'Setting the time to %s' % time(5)
    'Setting the time to 5'
    >>> time += 5
    >>> 'After incrementing by 5, the time is %s' % time()
    'After incrementing by 5, the time is 10'
    >>> with time as t:  # Entering a context
    ...     'Time before iteration: %s' % t()
    ...     'Iteration: %s' % [val for val in t]
    ...     'Time after iteration: %s' % t()
    ...     t += 2
    ...     'The until parameter may be exceeded outside iteration: %s' % t()
    'Time before iteration: 10'
    'Iteration: [10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]'
    'Time after iteration: 20'
    'The until parameter may be exceeded outside iteration: 22'
    >>> 'After exiting the context the time is back to %s' % time()
    'After exiting the context the time is back to 10'
    """
    _infinitely_iterable = ...
    forever = ...
    label = ...
    time_type = ...
    timestep = ...
    until = ...
    unit = ...
    def __init__(self, **params) -> None:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    
    def __iter__(self): # -> Self:
        ...
    
    def __next__(self): # -> Any:
        ...
    
    def __call__(self, val=..., time_type=...): # -> Any:
        """
        When called with no arguments, returns the current time value.

        When called with a specified val, sets the time to it.

        When called with a specified time_type, changes the time_type
        and sets the current time to the given val (which *must* be
        specified) converted to that time type.  To ensure that
        the current state remains consistent, this is normally the only
        way to change the time_type of an existing Time instance.
        """
        ...
    
    def advance(self, val): # -> None:
        ...
    
    def __iadd__(self, other): # -> Self:
        ...
    
    def __isub__(self, other): # -> Self:
        ...
    
    def __enter__(self): # -> Self:
        """Enter the context and push the current state."""
        ...
    
    def __exit__(self, exc, *args): # -> Literal[True] | None:
        """
        Exit from the current context, restoring the previous state.
        The StopIteration exception raised in context will force the
        context to exit. Any other exception exc that is raised in the
        block will not be caught.
        """
        ...
    


class Dynamic(Parameter):
    """
    Parameter whose value can be generated dynamically by a callable
    object.

    If a Parameter is declared as Dynamic, it can be set a callable
    object (such as a function or callable class), and getting the
    parameter's value will call that callable.

    Note that at present, the callable object must allow attributes
    to be set on itself.

    If set as time_dependent, setting the Dynamic.time_fn allows the
    production of dynamic values to be controlled: a new value will be
    produced only if the current value of time_fn is different from
    what it was the last time the parameter value was requested.

    By default, the Dynamic parameters are not time_dependent so that
    new values are generated on every call regardless of the time. The
    default time_fn used when time_dependent is a single Time instance
    that allows general manipulations of time. It may be set to some
    other callable as required so long as a number is returned on each
    call.
    """
    time_fn = ...
    time_dependent = ...
    @typing.overload
    def __init__(self, default=..., *, doc=..., label=..., precedence=..., instantiate=..., constant=..., readonly=..., pickle_default_value=..., allow_None=..., per_instance=..., allow_refs=..., nested_refs=...) -> None:
        ...
    
    def __init__(self, default=..., **params) -> None:
        """
        Call the superclass's __init__ and set instantiate=True if the
        default is dynamic.
        """
        ...
    
    def __get__(self, obj, objtype): # -> _Undefined | Any | object:
        """
        Call the superclass's __get__; if the result is not dynamic
        return that result, otherwise ask that result to produce a
        value and return it.
        """
        ...
    
    @instance_descriptor
    def __set__(self, obj, val): # -> None:
        """
        Call the superclass's set and keep this parameter's
        instantiate value up to date (dynamic parameters
        must be instantiated).

        If val is dynamic, initialize it as a generator.
        """
        ...
    


class __compute_set_hook:
    """Remove when set_hook is removed"""
    def __call__(self, p): # -> Callable[..., Any]:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    @property
    def sig(self): # -> None:
        ...
    


_compute_set_hook = ...
class Number(Dynamic):
    """
    A numeric Dynamic Parameter, with a default value and optional bounds.

    There are two types of bounds: ``bounds`` and
    ``softbounds``.  ``bounds`` are hard bounds: the parameter must
    have a value within the specified range.  The default bounds are
    (None,None), meaning there are actually no hard bounds.  One or
    both bounds can be set by specifying a value
    (e.g. bounds=(None,10) means there is no lower bound, and an upper
    bound of 10). Bounds are inclusive by default, but exclusivity
    can be specified for each bound by setting inclusive_bounds
    (e.g. inclusive_bounds=(True,False) specifies an exclusive upper
    bound).

    Number is also a type of Dynamic parameter, so its value
    can be set to a callable to get a dynamically generated
    number (see Dynamic).

    When not being dynamically generated, bounds are checked when a
    Number is created or set. Using a default value outside the hard
    bounds, or one that is not numeric, results in an exception. When
    being dynamically generated, bounds are checked when the value
    of a Number is requested. A generated value that is not numeric,
    or is outside the hard bounds, results in an exception.

    As a special case, if allow_None=True (which is true by default if
    the parameter has a default of None when declared) then a value
    of None is also allowed.

    A separate function set_in_bounds() is provided that will
    silently crop the given value into the legal range, for use
    in, for instance, a GUI.

    ``softbounds`` are present to indicate the typical range of
    the parameter, but are not enforced. Setting the soft bounds
    allows, for instance, a GUI to know what values to display on
    sliders for the Number.

    Example of creating a Number::

      AB = Number(default=0.5, bounds=(None,10), softbounds=(0,1), doc='Distance from A to B.')

    """
    __slots__ = ...
    _slot_defaults = ...
    @typing.overload
    def __init__(self, default=..., *, bounds=..., softbounds=..., inclusive_bounds=..., step=..., set_hook=..., allow_None=..., doc=..., label=..., precedence=..., instantiate=..., constant=..., readonly=..., pickle_default_value=..., per_instance=..., allow_refs=..., nested_refs=...) -> None:
        ...
    
    @_deprecate_positional_args
    def __init__(self, default=..., *, bounds=..., softbounds=..., inclusive_bounds=..., step=..., set_hook=..., **params) -> None:
        """
        Initialize this parameter object and store the bounds.

        Non-dynamic default values are checked against the bounds.
        """
        ...
    
    def __get__(self, obj, objtype): # -> _Undefined | Any | object:
        """
        Same as the superclass's __get__, but if the value was
        dynamically generated, check the bounds.
        """
        ...
    
    def set_in_bounds(self, obj, val): # -> None:
        """
        Set to the given value, but cropped to be within the legal bounds.
        All objects are accepted, and no exceptions will be raised.  See
        crop_to_bounds for details on how cropping is done.
        """
        ...
    
    def crop_to_bounds(self, val): # -> _Undefined | Any:
        """
        Return the given value cropped to be within the hard bounds
        for this parameter.

        If a numeric value is passed in, check it is within the hard
        bounds. If it is larger than the high bound, return the high
        bound. If it's smaller, return the low bound. In either case, the
        returned value could be None.  If a non-numeric value is passed
        in, set to be the default value (which could be None).  In no
        case is an exception raised; all values are accepted.

        As documented in https://github.com/holoviz/param/issues/80,
        currently does not respect exclusive bounds, which would
        strictly require setting to one less for integer values or
        an epsilon less for floats.
        """
        ...
    
    def get_soft_bounds(self): # -> tuple[Any | None, Any | None]:
        ...
    
    def __setstate__(self, state): # -> None:
        ...
    


class Integer(Number):
    """Numeric Parameter required to be an Integer"""
    _slot_defaults = ...


class Magnitude(Number):
    """Numeric Parameter required to be in the range [0.0-1.0]."""
    _slot_defaults = ...
    @typing.overload
    def __init__(self, default=..., *, bounds=..., softbounds=..., inclusive_bounds=..., step=..., set_hook=..., allow_None=..., doc=..., label=..., precedence=..., instantiate=..., constant=..., readonly=..., pickle_default_value=..., per_instance=..., allow_refs=..., nested_refs=...) -> None:
        ...
    
    def __init__(self, default=..., *, bounds=..., softbounds=..., inclusive_bounds=..., step=..., set_hook=..., **params) -> None:
        ...
    


class Date(Number):
    """Date parameter of datetime or date type."""
    _slot_defaults = ...
    @typing.overload
    def __init__(self, default=..., *, bounds=..., softbounds=..., inclusive_bounds=..., step=..., set_hook=..., doc=..., label=..., precedence=..., instantiate=..., constant=..., readonly=..., pickle_default_value=..., allow_None=..., per_instance=..., allow_refs=..., nested_refs=...) -> None:
        ...
    
    def __init__(self, default=..., **kwargs) -> None:
        ...
    
    @classmethod
    def serialize(cls, value): # -> str | None:
        ...
    
    @classmethod
    def deserialize(cls, value): # -> datetime | None:
        ...
    


class CalendarDate(Number):
    """Parameter specifically allowing dates (not datetimes)."""
    _slot_defaults = ...
    @typing.overload
    def __init__(self, default=..., *, bounds=..., softbounds=..., inclusive_bounds=..., step=..., set_hook=..., doc=..., label=..., precedence=..., instantiate=..., constant=..., readonly=..., pickle_default_value=..., allow_None=..., per_instance=..., allow_refs=..., nested_refs=...) -> None:
        ...
    
    def __init__(self, default=..., **kwargs) -> None:
        ...
    
    @classmethod
    def serialize(cls, value): # -> None:
        ...
    
    @classmethod
    def deserialize(cls, value): # -> _Date | None:
        ...
    


class Boolean(Parameter):
    """Binary or tristate Boolean Parameter."""
    _slot_defaults = ...
    @typing.overload
    def __init__(self, default=..., *, allow_None=..., doc=..., label=..., precedence=..., instantiate=..., constant=..., readonly=..., pickle_default_value=..., per_instance=..., allow_refs=..., nested_refs=...) -> None:
        ...
    
    @_deprecate_positional_args
    def __init__(self, default=..., **params) -> None:
        ...
    


class Event(Boolean):
    """
    An Event Parameter is one whose value is intimately linked to the
    triggering of events for watchers to consume. Event has a Boolean
    value, which when set to True triggers the associated watchers (as
    any Parameter does) and then is automatically set back to
    False. Conversely, if events are triggered directly via `.trigger`,
    the value is transiently set to True (so that it's clear which of
    many parameters being watched may have changed), then restored to
    False when the triggering completes. An Event parameter is thus like
    a momentary switch or pushbutton with a transient True value that
    serves only to launch some other action (e.g. via a param.depends
    decorator), rather than encapsulating the action itself as
    param.Action does.
    """
    __slots__ = ...
    @typing.overload
    def __init__(self, default=..., *, allow_None=..., doc=..., label=..., precedence=..., instantiate=..., constant=..., readonly=..., pickle_default_value=..., per_instance=..., allow_refs=..., nested_refs=...) -> None:
        ...
    
    @_deprecate_positional_args
    def __init__(self, default=..., **params) -> None:
        ...
    
    @instance_descriptor
    def __set__(self, obj, val): # -> None:
        ...
    


class __compute_length_of_default:
    def __call__(self, p): # -> int:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    @property
    def sig(self): # -> None:
        ...
    


_compute_length_of_default = ...
class Tuple(Parameter):
    """A tuple Parameter (e.g. ('a',7.6,[3,5])) with a fixed tuple length."""
    __slots__ = ...
    _slot_defaults = ...
    @typing.overload
    def __init__(self, default=..., *, length=..., doc=..., label=..., precedence=..., instantiate=..., constant=..., readonly=..., pickle_default_value=..., allow_None=..., per_instance=..., allow_refs=..., nested_refs=...) -> None:
        ...
    
    @_deprecate_positional_args
    def __init__(self, default=..., *, length=..., **params) -> None:
        """
        Initialize a tuple parameter with a fixed length (number of
        elements).  The length is determined by the initial default
        value, if any, and must be supplied explicitly otherwise.  The
        length is not allowed to change after instantiation.
        """
        ...
    
    @classmethod
    def serialize(cls, value): # -> list[Any] | None:
        ...
    
    @classmethod
    def deserialize(cls, value): # -> tuple[Any, ...] | None:
        ...
    


class NumericTuple(Tuple):
    """A numeric tuple Parameter (e.g. (4.5,7.6,3)) with a fixed tuple length."""
    ...


class XYCoordinates(NumericTuple):
    """A NumericTuple for an X,Y coordinate."""
    _slot_defaults = ...
    @typing.overload
    def __init__(self, default=..., *, length=..., allow_None=..., doc=..., label=..., precedence=..., instantiate=..., constant=..., readonly=..., pickle_default_value=..., per_instance=..., allow_refs=..., nested_refs=...) -> None:
        ...
    
    def __init__(self, default=..., **params) -> None:
        ...
    


class Range(NumericTuple):
    """A numeric range with optional bounds and softbounds."""
    __slots__ = ...
    _slot_defaults = ...
    @typing.overload
    def __init__(self, default=..., *, bounds=..., softbounds=..., inclusive_bounds=..., step=..., length=..., doc=..., label=..., precedence=..., instantiate=..., constant=..., readonly=..., pickle_default_value=..., allow_None=..., per_instance=..., allow_refs=..., nested_refs=...) -> None:
        ...
    
    @_deprecate_positional_args
    def __init__(self, default=..., *, bounds=..., softbounds=..., inclusive_bounds=..., step=..., **params) -> None:
        ...
    
    def get_soft_bounds(self): # -> tuple[Any | None, Any | None]:
        ...
    
    def rangestr(self): # -> str:
        ...
    


class DateRange(Range):
    """
    A datetime or date range specified as (start, end).

    Bounds must be specified as datetime or date types (see param.dt_types).
    """
    @classmethod
    def serialize(cls, value): # -> list[Any] | None:
        ...
    
    def deserialize(cls, value): # -> tuple[Any, ...] | None:
        ...
    


class CalendarDateRange(Range):
    """A date range specified as (start_date, end_date)."""
    @classmethod
    def serialize(cls, value): # -> list[Any] | None:
        ...
    
    @classmethod
    def deserialize(cls, value): # -> tuple[_Date, ...] | None:
        ...
    


class Callable(Parameter):
    """
    Parameter holding a value that is a callable object, such as a function.

    A keyword argument instantiate=True should be provided when a
    function object is used that might have state.  On the other hand,
    regular standalone functions cannot be deepcopied as of Python
    2.4, so instantiate must be False for those values.
    """
    @typing.overload
    def __init__(self, default=..., *, allow_None=..., doc=..., label=..., precedence=..., instantiate=..., constant=..., readonly=..., pickle_default_value=..., per_instance=..., allow_refs=..., nested_refs=...) -> None:
        ...
    
    @_deprecate_positional_args
    def __init__(self, default=..., **params) -> None:
        ...
    


class Action(Callable):
    """
    A user-provided function that can be invoked like a class or object method using ().
    In a GUI, this might be mapped to a button, but it can be invoked directly as well.
    """
    ...


class Composite(Parameter):
    """
    A Parameter that is a composite of a set of other attributes of the class.

    The constructor argument 'attribs' takes a list of attribute
    names, which may or may not be Parameters.  Getting the parameter
    returns a list of the values of the constituents of the composite,
    in the order specified.  Likewise, setting the parameter takes a
    sequence of values and sets the value of the constituent
    attributes.

    This Parameter type has not been tested with watchers and
    dependencies, and may not support them properly.
    """
    __slots__ = ...
    @typing.overload
    def __init__(self, *, attribs=..., allow_None=..., doc=..., label=..., precedence=..., instantiate=..., constant=..., readonly=..., pickle_default_value=..., per_instance=..., allow_refs=..., nested_refs=...) -> None:
        ...
    
    @_deprecate_positional_args
    def __init__(self, *, attribs=..., **kw) -> None:
        ...
    
    def __get__(self, obj, objtype): # -> list[Any]:
        """Return the values of all the attribs, as a list."""
        ...
    


class SelectorBase(Parameter):
    """
    Parameter whose value must be chosen from a list of possibilities.

    Subclasses must implement get_range().
    """
    __abstract = ...
    def get_range(self):
        ...
    


class ListProxy(list):
    """
    Container that supports both list-style and dictionary-style
    updates. Useful for replacing code that originally accepted lists
    but needs to support dictionary access (typically for naming
    items).
    """
    def __init__(self, iterable, parameter=...) -> None:
        ...
    
    def __getitem__(self, index):
        ...
    
    def __setitem__(self, index, object, trigger=...): # -> None:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    
    def append(self, object): # -> None:
        ...
    
    def copy(self): # -> list[Any]:
        ...
    
    def clear(self): # -> None:
        ...
    
    def extend(self, objects): # -> None:
        ...
    
    def get(self, key, default=...): # -> None:
        ...
    
    def insert(self, index, object): # -> None:
        ...
    
    def items(self): # -> _odict_items[Any, Any]:
        ...
    
    def keys(self): # -> _odict_keys[Any, Any]:
        ...
    
    def pop(self, *args): # -> None:
        ...
    
    def remove(self, object): # -> None:
        ...
    
    def update(self, objects, **items): # -> None:
        ...
    
    def values(self): # -> _odict_values[Any, Any]:
        ...
    


class __compute_selector_default:
    """
    Using a function instead of setting default to [] in _slot_defaults, as
    if it were modified in place later, which would happen with check_on_set set to False,
    then the object in _slot_defaults would itself be updated and the next Selector
    instance created wouldn't have [] as the default but a populated list.
    """
    def __call__(self, p): # -> list[Any]:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    @property
    def sig(self): # -> list[Any]:
        ...
    


_compute_selector_default = ...
class __compute_selector_checking_default:
    def __call__(self, p): # -> bool:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    @property
    def sig(self): # -> None:
        ...
    


_compute_selector_checking_default = ...
class _SignatureSelector(Parameter):
    _slot_defaults = ...


class Selector(SelectorBase, _SignatureSelector):
    """
    Parameter whose value must be one object from a list of possible objects.

    By default, if no default is specified, picks the first object from
    the provided set of objects, as long as the objects are in an
    ordered data collection.

    check_on_set restricts the value to be among the current list of
    objects. By default, if objects are initially supplied,
    check_on_set is True, whereas if no objects are initially
    supplied, check_on_set is False. This can be overridden by
    explicitly specifying check_on_set initially.

    If check_on_set is True (either because objects are supplied
    initially, or because it is explicitly specified), the default
    (initial) value must be among the list of objects (unless the
    default value is None).

    The list of objects can be supplied as a list (appropriate for
    selecting among a set of strings, or among a set of objects with a
    "name" parameter), or as a (preferably ordered) dictionary from
    names to objects.  If a dictionary is supplied, the objects
    will need to be hashable so that their names can be looked
    up from the object value.

    empty_default is an internal argument that does not have a slot.
    """
    __slots__ = ...
    @typing.overload
    def __init__(self, *, objects=..., default=..., instantiate=..., compute_default_fn=..., check_on_set=..., allow_None=..., empty_default=..., doc=..., label=..., precedence=..., constant=..., readonly=..., pickle_default_value=..., per_instance=..., allow_refs=..., nested_refs=...) -> None:
        ...
    
    @_deprecate_positional_args
    def __init__(self, *, objects=..., default=..., instantiate=..., compute_default_fn=..., check_on_set=..., allow_None=..., empty_default=..., **params) -> None:
        ...
    
    @property
    def objects(self): # -> ListProxy:
        ...
    
    @objects.setter
    def objects(self, objects): # -> None:
        ...
    
    def compute_default(self): # -> None:
        """
        If this parameter's compute_default_fn is callable, call it
        and store the result in self.default.

        Also removes None from the list of objects (if the default is
        no longer None).
        """
        ...
    
    def get_range(self): # -> OrderedDict[Any, Any]:
        """
        Return the possible objects to which this parameter could be set.

        (Returns the dictionary {object.name: object}.)
        """
        ...
    


class ObjectSelector(Selector):
    """
    Deprecated. Same as Selector, but with a different constructor for
    historical reasons.
    """
    @typing.overload
    def __init__(self, default=..., *, objects=..., instantiate=..., compute_default_fn=..., check_on_set=..., allow_None=..., empty_default=..., doc=..., label=..., precedence=..., constant=..., readonly=..., pickle_default_value=..., per_instance=..., allow_refs=..., nested_refs=...) -> None:
        ...
    
    @_deprecate_positional_args
    def __init__(self, default=..., *, objects=..., **kwargs) -> None:
        ...
    


class FileSelector(Selector):
    """Given a path glob, allows one file to be selected from those matching."""
    __slots__ = ...
    _slot_defaults = ...
    @typing.overload
    def __init__(self, default=..., *, path=..., objects=..., instantiate=..., compute_default_fn=..., check_on_set=..., allow_None=..., empty_default=..., doc=..., label=..., precedence=..., constant=..., readonly=..., pickle_default_value=..., per_instance=..., allow_refs=..., nested_refs=...) -> None:
        ...
    
    @_deprecate_positional_args
    def __init__(self, default=..., *, path=..., **kwargs) -> None:
        ...
    
    def update(self, path=...): # -> None:
        ...
    
    def get_range(self): # -> OrderedDict[Any, Any]:
        ...
    


class ListSelector(Selector):
    """
    Variant of Selector where the value can be multiple objects from
    a list of possible objects.
    """
    @typing.overload
    def __init__(self, default=..., *, objects=..., instantiate=..., compute_default_fn=..., check_on_set=..., allow_None=..., empty_default=..., doc=..., label=..., precedence=..., constant=..., readonly=..., pickle_default_value=..., per_instance=..., allow_refs=..., nested_refs=...) -> None:
        ...
    
    @_deprecate_positional_args
    def __init__(self, default=..., *, objects=..., **kwargs) -> None:
        ...
    
    def compute_default(self): # -> None:
        ...
    


class MultiFileSelector(ListSelector):
    """Given a path glob, allows multiple files to be selected from the list of matches."""
    __slots__ = ...
    _slot_defaults = ...
    @typing.overload
    def __init__(self, default=..., *, path=..., objects=..., compute_default_fn=..., check_on_set=..., allow_None=..., empty_default=..., doc=..., label=..., precedence=..., instantiate=..., constant=..., readonly=..., pickle_default_value=..., per_instance=..., allow_refs=..., nested_refs=...) -> None:
        ...
    
    @_deprecate_positional_args
    def __init__(self, default=..., *, path=..., **kwargs) -> None:
        ...
    
    def update(self, path=...): # -> None:
        ...
    
    def get_range(self): # -> OrderedDict[Any, Any]:
        ...
    


class ClassSelector(SelectorBase):
    """
    Parameter allowing selection of either a subclass or an instance of a class or tuple of classes.
    By default, requires an instance, but if is_instance=False, accepts a class instead.
    Both class and instance values respect the instantiate slot, though it matters only
    for is_instance=True.
    """
    __slots__ = ...
    _slot_defaults = ...
    @typing.overload
    def __init__(self, *, class_, default=..., instantiate=..., is_instance=..., allow_None=..., doc=..., label=..., precedence=..., constant=..., readonly=..., pickle_default_value=..., per_instance=..., allow_refs=..., nested_refs=...) -> None:
        ...
    
    @_deprecate_positional_args
    def __init__(self, *, class_, default=..., instantiate=..., is_instance=..., **params) -> None:
        ...
    
    def get_range(self): # -> OrderedDict[Any, Any]:
        """
        Return the possible types for this parameter's value.

        (I.e. return `{name: <class>}` for all classes that are
        concrete_descendents() of `self.class_`.)

        Only classes from modules that have been imported are added
        (see concrete_descendents()).
        """
        ...
    


class Dict(ClassSelector):
    """Parameter whose value is a dictionary."""
    @typing.overload
    def __init__(self, default=..., *, is_instance=..., allow_None=..., doc=..., label=..., precedence=..., instantiate=..., constant=..., readonly=..., pickle_default_value=..., per_instance=..., allow_refs=..., nested_refs=...) -> None:
        ...
    
    def __init__(self, default=..., **params) -> None:
        ...
    


class Array(ClassSelector):
    """Parameter whose value is a numpy array."""
    @typing.overload
    def __init__(self, default=..., *, is_instance=..., allow_None=..., doc=..., label=..., precedence=..., instantiate=..., constant=..., readonly=..., pickle_default_value=..., per_instance=..., allow_refs=..., nested_refs=...) -> None:
        ...
    
    def __init__(self, default=..., **params) -> None:
        ...
    
    @classmethod
    def serialize(cls, value): # -> None:
        ...
    
    @classmethod
    def deserialize(cls, value): # -> NDArray[Any] | None:
        ...
    


class DataFrame(ClassSelector):
    """
    Parameter whose value is a pandas DataFrame.

    The structure of the DataFrame can be constrained by the rows and
    columns arguments:

    rows: If specified, may be a number or an integer bounds tuple to
    constrain the allowable number of rows.

    columns: If specified, may be a number, an integer bounds tuple, a
    list or a set. If the argument is numeric, constrains the number of
    columns using the same semantics as used for rows. If either a list
    or set of strings, the column names will be validated. If a set is
    used, the supplied DataFrame must contain the specified columns and
    if a list is given, the supplied DataFrame must contain exactly the
    same columns and in the same order and no other columns.
    """
    __slots__ = ...
    _slot_defaults = ...
    @typing.overload
    def __init__(self, default=..., *, rows=..., columns=..., ordered=..., is_instance=..., allow_None=..., doc=..., label=..., precedence=..., instantiate=..., constant=..., readonly=..., pickle_default_value=..., per_instance=..., allow_refs=..., nested_refs=...) -> None:
        ...
    
    @_deprecate_positional_args
    def __init__(self, default=..., *, rows=..., columns=..., ordered=..., **params) -> None:
        ...
    
    @classmethod
    def serialize(cls, value): # -> None:
        ...
    
    @classmethod
    def deserialize(cls, value): # -> DataFrame | None:
        ...
    


class Series(ClassSelector):
    """
    Parameter whose value is a pandas Series.

    The structure of the Series can be constrained by the rows argument
    which may be a number or an integer bounds tuple to constrain the
    allowable number of rows.
    """
    __slots__ = ...
    _slot_defaults = ...
    @typing.overload
    def __init__(self, default=..., *, rows=..., allow_None=..., is_instance=..., doc=..., label=..., precedence=..., instantiate=..., constant=..., readonly=..., pickle_default_value=..., per_instance=..., allow_refs=..., nested_refs=...) -> None:
        ...
    
    @_deprecate_positional_args
    def __init__(self, default=..., *, rows=..., allow_None=..., **params) -> None:
        ...
    


class List(Parameter):
    """
    Parameter whose value is a list of objects, usually of a specified type.

    The bounds allow a minimum and/or maximum length of
    list to be enforced.  If the item_type is non-None, all
    items in the list are checked to be of that type.

    `class_` is accepted as an alias for `item_type`, but is
    deprecated due to conflict with how the `class_` slot is
    used in Selector classes.
    """
    __slots__ = ...
    _slot_defaults = ...
    @typing.overload
    def __init__(self, default=..., *, class_=..., item_type=..., instantiate=..., bounds=..., allow_None=..., doc=..., label=..., precedence=..., constant=..., readonly=..., pickle_default_value=..., per_instance=..., allow_refs=..., nested_refs=...) -> None:
        ...
    
    @_deprecate_positional_args
    def __init__(self, default=..., *, class_=..., item_type=..., instantiate=..., bounds=..., **params) -> None:
        ...
    


class HookList(List):
    """
    Parameter whose value is a list of callable objects.

    This type of List Parameter is typically used to provide a place
    for users to register a set of commands to be called at a
    specified place in some sequence of processing steps.
    """
    __slots__ = ...


class resolve_path(ParameterizedFunction):
    """
    Find the path to an existing file, searching the paths specified
    in the search_paths parameter if the filename is not absolute, and
    converting a UNIX-style path to the current OS's format if
    necessary.

    To turn a supplied relative path into an absolute one, the path is
    appended to paths in the search_paths parameter, in order, until
    the file is found.

    An IOError is raised if the file is not found.

    Similar to Python's os.path.abspath(), except more search paths
    than just os.getcwd() can be used, and the file must exist.
    """
    search_paths = ...
    path_to_file = ...
    def __call__(self, path, **params): # -> str:
        ...
    


@_deprecated(warning_cat=_ParamFutureWarning)
class normalize_path(ParameterizedFunction):
    """
    Convert a UNIX-style path to the current OS's format,
    typically for creating a new file or directory.

    If the path is not already absolute, it will be made absolute
    (using the prefix parameter).

    Should do the same as Python's os.path.abspath(), except using
    prefix rather than os.getcwd).
    """
    prefix = ...
    def __call__(self, path=..., **params): # -> str:
        ...
    


class Path(Parameter):
    """
    Parameter that can be set to a string specifying the path of a file or folder.

    The string should be specified in UNIX style, but it will be
    returned in the format of the user's operating system. Please use
    the Filename or Foldername Parameters if you require discrimination
    between the two possibilities.

    The specified path can be absolute, or relative to either:

    * any of the paths specified in the search_paths attribute (if
       search_paths is not None);

    or

    * any of the paths searched by resolve_path() (if search_paths
      is None).

    Parameters
    ----------
    search_paths : list, default=[os.getcwd()]
        List of paths to search the path from
    check_exists: boolean, default=True
        If True (default) the path must exist on instantiation and set,
        otherwise the path can optionally exist.

    """
    __slots__ = ...
    _slot_defaults = ...
    @typing.overload
    def __init__(self, default=..., *, search_paths=..., check_exists=..., allow_None=..., doc=..., label=..., precedence=..., instantiate=..., constant=..., readonly=..., pickle_default_value=..., per_instance=..., allow_refs=..., nested_refs=...) -> None:
        ...
    
    @_deprecate_positional_args
    def __init__(self, default=..., *, search_paths=..., check_exists=..., **params) -> None:
        ...
    
    def __get__(self, obj, objtype): # -> resolve_path | _Undefined | Any | None:
        """Return an absolute, normalized path (see resolve_path)."""
        ...
    
    def __getstate__(self): # -> dict[Any, Any]:
        ...
    


class Filename(Path):
    """
    Parameter that can be set to a string specifying the path of a file.

    The string should be specified in UNIX style, but it will be
    returned in the format of the user's operating system.

    The specified path can be absolute, or relative to either:

    * any of the paths specified in the search_paths attribute (if
      search_paths is not None);

    or

    * any of the paths searched by resolve_path() (if search_paths
      is None).
    """
    ...


class Foldername(Path):
    """
    Parameter that can be set to a string specifying the path of a folder.

    The string should be specified in UNIX style, but it will be
    returned in the format of the user's operating system.

    The specified path can be absolute, or relative to either:

    * any of the paths specified in the search_paths attribute (if
      search_paths is not None);

    or

    * any of the paths searched by resolve_dir_path() (if search_paths
      is None).
    """
    ...


class Color(Parameter):
    """
    Color parameter defined as a hex RGB string with an optional #
    prefix or (optionally) as a CSS3 color name.
    """
    _named_colors = ...
    __slots__ = ...
    _slot_defaults = ...
    @typing.overload
    def __init__(self, default=..., *, allow_named=..., allow_None=..., doc=..., label=..., precedence=..., instantiate=..., constant=..., readonly=..., pickle_default_value=..., per_instance=..., allow_refs=..., nested_refs=...) -> None:
        ...
    
    @_deprecate_positional_args
    def __init__(self, default=..., *, allow_named=..., **kwargs) -> None:
        ...
    


class Bytes(Parameter):
    """
    A Bytes Parameter, with a default value and optional regular
    expression (regex) matching.

    Similar to the String parameter, but instead of type string
    this parameter only allows objects of type bytes (e.g. b'bytes').
    """
    __slots__ = ...
    _slot_defaults = ...
    @typing.overload
    def __init__(self, default=..., *, regex=..., allow_None=..., doc=..., label=..., precedence=..., instantiate=..., constant=..., readonly=..., pickle_default_value=..., per_instance=..., allow_refs=..., nested_refs=...) -> None:
        ...
    
    @_deprecate_positional_args
    def __init__(self, default=..., *, regex=..., allow_None=..., **kwargs) -> None:
        ...
    


