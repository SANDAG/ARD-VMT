"""
This type stub file was generated by pyright.
"""

import typing
from contextlib import contextmanager
from ._utils import ParamFutureWarning as _ParamFutureWarning, _deprecate_positional_args, _deprecated, _in_ipython, _recursive_repr, accept_arguments

"""
Generic support for objects with full-featured Parameters and
messaging.

This file comes from the Param library (https://github.com/holoviz/param)
but can be taken out of the param module and used on its own if desired,
either alone (providing basic Parameter support) or with param's
__init__.py (providing specialized Parameter types).
"""
if _in_ipython():
    param_pager = ...
else:
    param_pager = ...
VERBOSE = ...
logger = ...
def get_logger(name=...): # -> Logger:
    ...

warnings_as_exceptions = ...
docstring_signature = ...
docstring_describe_params = ...
object_count = ...
warning_count = ...
_reference_transforms = ...
def register_reference_transform(transform): # -> None:
    """
    Appends a transform to extract potential parameter dependencies
    from an object.

    Arguments:
    ---------
    transform: Callable[Any, Any]

    """
    ...

def transform_reference(arg): # -> Parameter:
    """
    Applies transforms to turn objects which should be treated like
    a parameter reference into a valid reference that can be resolved
    by Param. This is useful for adding handling for depending on objects
    that are not simple Parameters or functions with dependency
    definitions.
    """
    ...

def eval_function_with_deps(function):
    """
    Evaluates a function after resolving its dependencies.

    Calls and returns a function after resolving any dependencies
    stored on the _dinfo attribute and passing the resolved values
    as arguments.
    """
    ...

def resolve_value(value, recursive=...): # -> list[Any] | tuple[Any, ...] | dict[Any, Any] | slice[Any, Any, Any] | AsyncGenerator[Any | object, Any] | GeneratorType[Any, Any, Any] | Any:
    """Resolves the current value of a dynamic reference."""
    ...

def resolve_ref(reference, recursive=...): # -> list[Any] | list[Parameter]:
    """Resolves all parameters a dynamic reference depends on."""
    ...

class _Undefined:
    """
    Dummy value to signal completely undefined values rather than
    simple None values.
    """
    def __bool__(self):
        ...
    
    def __repr__(self): # -> Literal['<Undefined>']:
        ...
    


Undefined = ...
@contextmanager
def logging_level(level): # -> Generator[None, Any, None]:
    """Temporarily modify param's logging level."""
    ...

@_deprecated(extra_msg="Use instead `batch_call_watchers`.", warning_cat=_ParamFutureWarning)
@contextmanager
def batch_watch(parameterized, enable=..., run=...): # -> Generator[None, Any, None]:
    ...

@contextmanager
def batch_call_watchers(parameterized): # -> Generator[None, Any, None]:
    """
    Context manager to batch events to provide to Watchers on a
    parameterized object.  This context manager queues any events
    triggered by setting a parameter on the supplied parameterized
    object, saving them up to dispatch them all at once when the
    context manager exits.
    """
    ...

@contextmanager
def edit_constant(parameterized): # -> Generator[None, Any, None]:
    """
    Temporarily set parameters on Parameterized object to constant=False
    to allow editing them.
    """
    ...

@contextmanager
def discard_events(parameterized): # -> Generator[None, Any, None]:
    """
    Context manager that discards any events within its scope
    triggered on the supplied parameterized object.
    """
    ...

def classlist(class_): # -> tuple[type, ...]:
    """
    Return a list of the class hierarchy above (and including) the given class.

    Same as `inspect.getmro(class_)[::-1]`
    """
    ...

def get_all_slots(class_): # -> list[Any]:
    """
    Return a list of slot names for slots defined in `class_` and its
    superclasses.
    """
    ...

def get_occupied_slots(instance): # -> list[Any]:
    """
    Return a list of slots for which values have been set.

    (While a slot might be defined, if a value for that slot hasn't
    been set, then it's an AttributeError to request the slot's
    value.)
    """
    ...

@_deprecated(warning_cat=_ParamFutureWarning)
def all_equal(arg1, arg2): # -> bool:
    """
    Return a single boolean for arg1==arg2, even for numpy arrays
    using element-wise comparison.

    Uses all(arg1==arg2) for sequences, and arg1==arg2 otherwise.

    If both objects have an '_infinitely_iterable' attribute, they are
    not be zipped together and are compared directly instead.
    """
    ...

@_deprecated(warning_cat=_ParamFutureWarning)
def add_metaclass(metaclass): # -> Callable[..., Any]:
    """
    Class decorator for creating a class with a metaclass.

    .. deprecated:: 2.0.0
    """
    ...

class bothmethod:
    """
    'optional @classmethod'

    A decorator that allows a method to receive either the class
    object (if called on the class) or the instance object
    (if called on the instance) as its first argument.
    """
    def __init__(self, method) -> None:
        ...
    
    def __get__(self, instance, owner):
        ...
    


def no_instance_params(cls):
    """Disables instance parameters on the class"""
    ...

def instance_descriptor(f): # -> Callable[..., Any | None]:
    ...

def get_method_owner(method): # -> object | None:
    """Gets the instance that owns the supplied method"""
    ...

def recursive_repr(fillvalue=...): # -> Callable[..., Callable[..., str | Any]]:
    """
    Decorator to make a repr function return fillvalue for a recursive call

    .. deprecated:: 1.12.0
    """
    ...

@accept_arguments
def output(func, *output, **kw): # -> _Wrapped[Callable[..., Any], Any, Callable[..., Any], Any]:
    """
    output allows annotating a method on a Parameterized class to
    declare that it returns an output of a specific type. The outputs
    of a Parameterized class can be queried using the
    Parameterized.param.outputs method. By default the output will
    inherit the method name but a custom name can be declared by
    expressing the Parameter type using a keyword argument.

    The simplest declaration simply declares the method returns an
    object without any type guarantees, e.g.:

      @output()

    If a specific parameter type is specified this is a declaration
    that the method will return a value of that type, e.g.:

      @output(param.Number())

    To override the default name of the output the type may be declared
    as a keyword argument, e.g.:

      @output(custom_name=param.Number())

    Multiple outputs may be declared using keywords mapping from output name
    to the type or using tuples of the same format, i.e. these two declarations
    are equivalent:

      @output(number=param.Number(), string=param.String())

      @output(('number', param.Number()), ('string', param.String()))

    output also accepts Python object types which will be upgraded to
    a ClassSelector, e.g.:

      @output(int)
    """
    ...

def extract_dependencies(function): # -> list[Any]:
    """Extract references from a method or function that declares the references."""
    ...

PInfo = ...
MInfo = ...
DInfo = ...
Event = ...
_Watcher = ...
class Watcher(_Watcher):
    """
    Object declaring a callback function to invoke when an Event is
    triggered on a watched item.

    `inst`: Parameterized instance owning the watched Parameter, or
    None

    `cls`: Parameterized class owning the watched Parameter

    `fn`: Callback function to invoke when triggered by a watched
    Parameter

    `mode`: 'args' for param.watch (call `fn` with PInfo object
    positional args), or 'kwargs' for param.watch_values (call `fn`
    with <param_name>:<new_value> keywords)

    `onlychanged`: If True, only trigger for actual changes, not
    setting to the current value

    `parameter_names`: List of Parameters to watch, by name

    `what`: What to watch on the Parameters (either 'value' or a slot
    name)

    `queued`: Immediately invoke callbacks triggered during processing
            of an Event (if False), or queue them up for processing
            later, after this event has been handled (if True)

    `precedence`: A numeric value which determines the precedence of
                  the watcher.  Lower precedence values are executed
                  with higher priority.
    """
    def __new__(cls_, *args, **kwargs): # -> Self:
        """Allows creating Watcher without explicit precedence value."""
        ...
    
    def __str__(self) -> str:
        ...
    


class ParameterMetaclass(type):
    """Metaclass allowing control over creation of Parameter classes."""
    def __new__(mcs, classname, bases, classdict): # -> Self:
        ...
    
    def __getattribute__(mcs, name): # -> Any:
        ...
    


class _ParameterBase(metaclass=ParameterMetaclass):
    """
    Base Parameter class used to dynamically update the signature of all
    the Parameters.
    """
    @classmethod
    def __init_subclass__(cls): # -> None:
        ...
    


class Parameter(_ParameterBase):
    """
    An attribute descriptor for declaring parameters.

    Parameters are a special kind of class attribute.  Setting a
    Parameterized class attribute to be a Parameter instance causes
    that attribute of the class (and the class's instances) to be
    treated as a Parameter.  This allows special behavior, including
    dynamically generated parameter values, documentation strings,
    constant and read-only parameters, and type or range checking at
    assignment time.

    For example, suppose someone wants to define two new kinds of
    objects Foo and Bar, such that Bar has a parameter delta, Foo is a
    subclass of Bar, and Foo has parameters alpha, sigma, and gamma
    (and delta inherited from Bar).  She would begin her class
    definitions with something like this::

       class Bar(Parameterized):
           delta = Parameter(default=0.6, doc='The difference between steps.')
           ...
       class Foo(Bar):
           alpha = Parameter(default=0.1, doc='The starting value.')
           sigma = Parameter(default=0.5, doc='The standard deviation.',
                           constant=True)
           gamma = Parameter(default=1.0, doc='The ending value.')
           ...

    Class Foo would then have four parameters, with delta defaulting
    to 0.6.

    Parameters have several advantages over plain attributes:

    1. Parameters can be set automatically when an instance is
       constructed: The default constructor for Foo (and Bar) will
       accept arbitrary keyword arguments, each of which can be used
       to specify the value of a Parameter of Foo (or any of Foo's
       superclasses).  E.g., if a script does this::

           myfoo = Foo(alpha=0.5)

       myfoo.alpha will return 0.5, without the Foo constructor
       needing special code to set alpha.

       If Foo implements its own constructor, keyword arguments will
       still be accepted if the constructor accepts a dictionary of
       keyword arguments (as in ``def __init__(self,**params):``), and
       then each class calls its superclass (as in
       ``super(Foo,self).__init__(**params)``) so that the
       Parameterized constructor will process the keywords.

    2. A Parameterized class need specify only the attributes of a
       Parameter whose values differ from those declared in
       superclasses; the other values will be inherited.  E.g. if Foo
       declares::

        delta = Parameter(default=0.2)

       the default value of 0.2 will override the 0.6 inherited from
       Bar, but the doc will be inherited from Bar.

    3. The Parameter descriptor class can be subclassed to provide
       more complex behavior, allowing special types of parameters
       that, for example, require their values to be numbers in
       certain ranges, generate their values dynamically from a random
       distribution, or read their values from a file or other
       external source.

    4. The attributes associated with Parameters provide enough
       information for automatically generating property sheets in
       graphical user interfaces, allowing Parameterized instances to
       be edited by users.

    Note that Parameters can only be used when set as class attributes
    of Parameterized classes. Parameters used as standalone objects,
    or as class attributes of non-Parameterized classes, will not have
    the behavior described here.
    """
    __slots__ = ...
    _serializers = ...
    _slot_defaults = ...
    _non_validated_slots = ...
    @typing.overload
    def __init__(self, default=..., *, doc=..., label=..., precedence=..., instantiate=..., constant=..., readonly=..., pickle_default_value=..., allow_None=..., per_instance=..., allow_refs=..., nested_refs=...) -> None:
        ...
    
    @_deprecate_positional_args
    def __init__(self, default=..., *, doc=..., label=..., precedence=..., instantiate=..., constant=..., readonly=..., pickle_default_value=..., allow_None=..., per_instance=..., allow_refs=..., nested_refs=...) -> None:
        """
        Initialize a new Parameter object and store the supplied attributes:

        default: the owning class's value for the attribute represented
        by this Parameter, which can be overridden in an instance.

        doc: docstring explaining what this parameter represents.

        label: optional text label to be used when this Parameter is
        shown in a listing. If no label is supplied, the attribute name
        for this parameter in the owning Parameterized object is used.

        precedence: a numeric value, usually in the range 0.0 to 1.0,
        which allows the order of Parameters in a class to be defined in
        a listing or e.g. in GUI menus. A negative precedence indicates
        a parameter that should be hidden in such listings.

        instantiate: controls whether the value of this Parameter will
        be deepcopied when a Parameterized object is instantiated (if
        True), or if the single default value will be shared by all
        Parameterized instances (if False). For an immutable Parameter
        value, it is best to leave instantiate at the default of
        False, so that a user can choose to change the value at the
        Parameterized instance level (affecting only that instance) or
        at the Parameterized class or superclass level (affecting all
        existing and future instances of that class or superclass). For
        a mutable Parameter value, the default of False is also appropriate
        if you want all instances to share the same value state, e.g. if
        they are each simply referring to a single global object like
        a singleton. If instead each Parameterized should have its own
        independently mutable value, instantiate should be set to
        True, but note that there is then no simple way to change the
        value of this Parameter at the class or superclass level,
        because each instance, once created, will then have an
        independently instantiated value.

        constant: if true, the Parameter value can be changed only at
        the class level or in a Parameterized constructor call. The
        value is otherwise constant on the Parameterized instance,
        once it has been constructed.

        readonly: if true, the Parameter value cannot ordinarily be
        changed by setting the attribute at the class or instance
        levels at all. The value can still be changed in code by
        temporarily overriding the value of this slot and then
        restoring it, which is useful for reporting values that the
        _user_ should never change but which do change during code
        execution.

        pickle_default_value: whether the default value should be
        pickled. Usually, you would want the default value to be pickled,
        but there are rare cases where that would not be the case (e.g.
        for file search paths that are specific to a certain system).

        per_instance: whether a separate Parameter instance will be
        created for every Parameterized instance. True by default.
        If False, all instances of a Parameterized class will share
        the same Parameter object, including all validation
        attributes (bounds, etc.). See also instantiate, which is
        conceptually similar but affects the Parameter value rather
        than the Parameter object.

        allow_None: if True, None is accepted as a valid value for
        this Parameter, in addition to any other values that are
        allowed. If the default value is defined as None, allow_None
        is set to True automatically.

        allow_refs: if True allows automatically linking parameter
        references to this Parameter, i.e. the parameter value will
        automatically reflect the current value of the reference that
        is passed in.

        nested_refs: if True and allow_refs=True then even nested objects
        such as dictionaries, lists, slices, tuples and sets will be
        inspected for references and will be automatically resolved.

        default, doc, and precedence all default to None, which allows
        inheritance of Parameter slots (attributes) from the owning-class'
        class hierarchy (see ParameterizedMetaclass).
        """
        ...
    
    @classmethod
    def serialize(cls, value):
        """Given the parameter value, return a Python value suitable for serialization"""
        ...
    
    @classmethod
    def deserialize(cls, value):
        """Given a serializable Python value, return a value that the parameter can be set to"""
        ...
    
    def schema(self, safe=..., subset=..., mode=...): # -> dict[str, list[Any]] | Any | dict[str, Any]:
        ...
    
    @property
    def rx(self): # -> reactive_ops:
        """
        The reactive namespace.

        Provides reactive versions of operations that cannot be made reactive through operator overloading, such as
        `.rx.and_` and `.rx.bool`. Calling this namespace (`()`) returns a reactive expression.

        Returns
        -------
        Reactive expression
            The result of calling the reactive namespace is a reactive expression.

        User Guide
        ----------
        https://param.holoviz.org/user_guide/Reactive_Expressions.html#special-methods-on-rx

        Examples
        --------
        Create a Parameterized instance:

        >>> import param
        >>> class P(param.Parameterized):
        ...     a = param.Number()
        >>> p = P(a=1)

        Get the current value:

        >>> a = p.param.a.rx.value

        Call it to get a reactive expression:

        >>> rx_value = p.param.a.rx()

        """
        ...
    
    @property
    def label(self): # -> label_formatter | _Undefined:
        ...
    
    @label.setter
    def label(self, val): # -> None:
        ...
    
    def __setattr__(self, attribute, value): # -> None:
        ...
    
    def __getattribute__(self, key): # -> bool | Any | None:
        """
        Allow slot values to be Undefined in an "unbound" parameter, i.e. one
        that is not (yet) owned by a Parameterized object, in which case their
        value will be retrieved from the _slot_defaults dictionary.
        """
        ...
    
    def __get__(self, obj, objtype): # -> _Undefined | Any:
        """
        Return the value for this Parameter.

        If called for a Parameterized class, produce that
        class's value (i.e. this Parameter object's 'default'
        attribute).

        If called for a Parameterized instance, produce that
        instance's value, if one has been set - otherwise produce the
        class's value (default).
        """
        ...
    
    @instance_descriptor
    def __set__(self, obj, val):
        """
        Set the value for this Parameter.

        If called for a Parameterized class, set that class's
        value (i.e. set this Parameter object's 'default' attribute).

        If called for a Parameterized instance, set the value of
        this Parameter on that instance (i.e. in the instance's
        `values` dictionary located in the private namespace `_param__private`,
        under the parameter's name).

        If the Parameter's constant attribute is True, only allows
        the value to be set for a Parameterized class or on
        uninitialized Parameterized instances.

        If the Parameter's readonly attribute is True, only allows the
        value to be specified in the Parameter declaration inside the
        Parameterized source code. A read-only parameter also
        cannot be set on a Parameterized class.

        Note that until we support some form of read-only
        object, it is still possible to change the attributes of the
        object stored in a constant or read-only Parameter (e.g. one
        item in a list).
        """
        ...
    
    def __delete__(self, obj):
        ...
    
    def __getstate__(self): # -> dict[Any, Any]:
        """
        All Parameters have slots, not a dict, so we have to support
        pickle and deepcopy ourselves.
        """
        ...
    
    def __setstate__(self, state): # -> None:
        ...
    


class String(Parameter):
    r"""
    A String Parameter, with a default value and optional regular expression (regex) matching.

    Example of using a regex to implement IPv4 address matching::

      class IPAddress(String):
        '''IPv4 address as a string (dotted decimal notation)'''
       def __init__(self, default="0.0.0.0", allow_None=False, **kwargs):
           ip_regex = r'^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$'
           super(IPAddress, self).__init__(default=default, regex=ip_regex, **kwargs)

    """
    __slots__ = ...
    _slot_defaults = ...
    @typing.overload
    def __init__(self, default=..., *, regex=..., doc=..., label=..., precedence=..., instantiate=..., constant=..., readonly=..., pickle_default_value=..., allow_None=..., per_instance=..., allow_refs=..., nested_refs=...) -> None:
        ...
    
    @_deprecate_positional_args
    def __init__(self, default=..., *, regex=..., **kwargs) -> None:
        ...
    


class shared_parameters:
    """
    Context manager to share parameter instances when creating
    multiple Parameterized objects of the same type. Parameter default
    values are instantiated once and cached to be reused when another
    Parameterized object of the same type is instantiated.
    Can be useful to easily modify large collections of Parameterized
    objects at once and can provide a significant speedup.
    """
    _share = ...
    _shared_cache = ...
    def __enter__(self): # -> None:
        ...
    
    def __exit__(self, exc_type, exc_val, exc_tb): # -> None:
        ...
    


def as_uninitialized(fn): # -> _Wrapped[Callable[..., Any], Any, Callable[..., Any], Any]:
    """
    Decorator: call fn with the parameterized_instance's
    initialization flag set to False, then revert the flag.

    (Used to decorate Parameterized methods that must alter
    a constant Parameter.)
    """
    ...

class Comparator:
    """
    Comparator defines methods for determining whether two objects
    should be considered equal. It works by registering custom
    comparison functions, which may either be registed by type or with
    a predicate function. If no matching comparison can be found for
    the two objects the comparison will return False.

    If registered by type the Comparator will check whether both
    objects are of that type and apply the comparison. If the equality
    function is instead registered with a function it will call the
    function with each object individually to check if the comparison
    applies. This is useful for defining comparisons for objects
    without explicitly importing them.

    To use the Comparator simply call the is_equal function.
    """
    equalities = ...
    gen_equalities = ...
    @classmethod
    def is_equal(cls, obj1, obj2): # -> Any | bool:
        ...
    
    @classmethod
    def compare_iterator(cls, obj1, obj2): # -> bool:
        ...
    
    @classmethod
    def compare_mapping(cls, obj1, obj2): # -> bool:
        ...
    


class _ParametersRestorer:
    """Context-manager to handle the reset of parameter values after an update."""
    def __init__(self, *, parameters, restore, refs=...) -> None:
        ...
    
    def __enter__(self): # -> Any | dict[Any, Any]:
        ...
    
    def __exit__(self, exc_type, exc_value, exc_tb): # -> None:
        ...
    


class Parameters:
    """
    Object that holds the namespace and implementation of Parameterized
    methods as well as any state that is not in __slots__ or the
    Parameters themselves.

    Exists at both the metaclass level (instantiated by the metaclass)
    and at the instance level. Can contain state specific to either the
    class or the instance as necessary.
    """
    def __init__(self_, cls, self=...) -> None:
        """
        cls is the Parameterized class which is always set.
        self is the instance if set.
        """
        ...
    
    @property
    def watchers(self_):
        """Dictionary of instance watchers."""
        ...
    
    @watchers.setter
    def watchers(self_, value): # -> None:
        ...
    
    @property
    def self_or_cls(self_): # -> Any:
        ...
    
    def __setstate__(self, state): # -> None:
        ...
    
    def __getitem__(self_, key):
        """Returns the class or instance parameter"""
        ...
    
    def __dir__(self_):
        """Adds parameters to dir"""
        ...
    
    def __iter__(self_): # -> Generator[Any, Any, None]:
        """Iterates over the parameters on this object."""
        ...
    
    def __contains__(self_, param): # -> bool:
        ...
    
    def __getattr__(self_, attr):
        """Extends attribute access to parameter objects."""
        ...
    
    @_deprecated(extra_msg="""Use instead `for k,v in p.param.objects().items(): print(f"{p.__class__.name}.{k}={repr(v.default)}")`""", warning_cat=_ParamFutureWarning)
    def print_param_defaults(self_): # -> None:
        """
        Print the default values of all cls's Parameters.

        .. deprecated:: 1.12.0
            Use instead `for k,v in p.param.objects().items(): print(f"{p.__class__.name}.{k}={repr(v.default)}")`
        """
        ...
    
    @_deprecated(extra_msg="Use instead `p.param.default =`", warning_cat=_ParamFutureWarning)
    def set_default(self_, param_name, value): # -> None:
        """
        Set the default value of param_name.

        Equivalent to setting param_name on the class.

        .. deprecated:: 1.12.0
             Use instead `p.param.default =`
        """
        ...
    
    def add_parameter(self_, param_name: str, param_obj: Parameter): # -> None:
        """
        Add a new Parameter object to this class.

        This method allows dynamically adding a Parameter to the class, resulting in behavior equivalent to declaring
        the Parameter in the class's source code.

        Parameters
        ----------
        param_name : str
            The name of the parameter to add.
        param_obj : Parameter
            The Parameter object to add.

        Examples
        --------
        Create a Parameterized class:

        >>> import param
        >>> class P(param.Parameterized):
        ...     a = param.Number()
        ...     b = param.String()
        >>> p = P()

        Add a new parameter to the class `P` via the class namespace `P.param`:

        >>> P.param.add_parameter('c', param.Tuple(default=(1, 2, 3)))
        >>> print(p.c)
        (1, 2, 3)

        Add a new parameter to the class `P` via the instance namespace `p.param`:

        >>> p.param.add_parameter('d', param.Tuple(default=(3, 2, 1)))
        >>> p.d
        (3, 2, 1)

        """
        ...
    
    @_deprecated(extra_msg="Use instead `.param.values()` or `.param['param']`", warning_cat=_ParamFutureWarning)
    def params(self_, parameter_name=...): # -> dict[Any, Any]:
        """
        Return the Parameters of this class as the
        dictionary {name: parameter_object}

        Includes Parameters from this class and its
        superclasses.

        .. deprecated:: 1.12.0
            Use instead `.param.values()` or `.param['param']`
        """
        ...
    
    def update(self_, arg=..., /, **kwargs): # -> _ParametersRestorer:
        """
        Update multiple parameters of this object or class before triggering events.

        Allows setting the parameters of the object or class using a dictionary, an iterable, or keyword arguments
        in the form of `param=value`. The specified parameters will be updated to the given values.

        This method can also be used as a context manager to temporarily set and then reset parameter values.

        Parameters
        ----------
        **params : dict or iterable or keyword arguments
            The parameters to update, provided as a dictionary, iterable, or keyword arguments in `param=value` format.

        User Guide
        ----------
        https://param.holoviz.org/user_guide/Parameters.html#other-parameterized-methods

        Examples
        --------
        Create a Parameterized class:

        >>> import param
        >>> class P(param.Parameterized):
        ...    a = param.String()
        ...    b = param.String()

        Define the instance:

        >>> p = P(a="0. Hello", b="0. World")

        Use `.update` to update the parameters:

        >>> p.param.update(a="1. Hello", b="2. World")
        >>> p.a, p.b
        ('1. Hello', '1. World')

        Update the parameters temporarily:

        >>> with p.param.update(a="2. Hello", b="2. World"):
        ...     print(p.a, p.b)
        2. Hello 2. World

        >>> p.a, p.b
        ('1. Hello', '1. World')

        Lets see that events are triggered **after** all parameters have been updated

        >>> @param.depends(p.param.a, watch=True)
        ... def print_a_b(a):
        ...     print(p.a, p.b)
        >>> my_param.param.update(a="3. Hello",b="3. World")
        3. Hello 3. World

        """
        ...
    
    @_deprecated(extra_msg="Use instead `.param.update`", warning_cat=_ParamFutureWarning)
    def set_param(self_, *args, **kwargs): # -> _ParametersRestorer:
        """
        For each param=value keyword argument, sets the corresponding
        parameter of this object or class to the given value.

        For backwards compatibility, also accepts
        set_param("param",value) for a single parameter value using
        positional arguments, but the keyword interface is preferred
        because it is more compact and can set multiple values.

        .. deprecated:: 1.12.0
            Use instead `.param.update`
        """
        ...
    
    def objects(self_, instance=...): # -> dict[Any, Any]:
        """
        Returns the Parameters of this instance or class

        If instance=True and called on a Parameterized instance it
        will create instance parameters for all Parameters defined on
        the class. To force class parameters to be returned use
        instance=False. Since classes avoid creating instance
        parameters unless necessary you may also request only existing
        instance parameters to be returned by setting
        instance='existing'.
        """
        ...
    
    def trigger(self_, *param_names): # -> None:
        """
        Trigger watchers for the given set of parameter names. Watchers
        will be triggered whether or not the parameter values have
        actually changed. As a special case, the value will actually be
        changed for a Parameter of type Event, setting it to True so
        that it is clear which Event parameter has been triggered.
        """
        ...
    
    def set_dynamic_time_fn(self_, time_fn, sublistattr=...): # -> None:
        """
        Set time_fn for all Dynamic Parameters of this class or
        instance object that are currently being dynamically
        generated.

        Additionally, sets _Dynamic_time_fn=time_fn on this class or
        instance object, so that any future changes to Dynamic
        Parmeters can inherit time_fn (e.g. if a Number is changed
        from a float to a number generator, the number generator will
        inherit time_fn).

        If specified, sublistattr is the name of an attribute of this
        class or instance that contains an iterable collection of
        subobjects on which set_dynamic_time_fn should be called.  If
        the attribute sublistattr is present on any of the subobjects,
        set_dynamic_time_fn() will be called for those, too.
        """
        ...
    
    def serialize_parameters(self_, subset=..., mode=...): # -> str:
        """
        Return the serialized parameters of the Parameterized object.

        Parameters
        ----------
        subset : list, optional
            A list of parameter names to serialize. If None, all parameters will be serialized. Defaults to None.
        mode : str, optional
            The serialization format. By default, only 'json' is supported. Defaults to 'json'.

        Returns
        -------
        Any
            The serialized value.

        User Guide
        ----------
        https://param.holoviz.org/user_guide/Serialization_and_Persistence.html#serializing-with-json

        Examples
        --------
        Create a Parameterized instance and serialize its parameters:

        >>> import param
        >>> class P(param.Parameterized):
        ...     a = param.Number()
        ...     b = param.String()
        >>> p = P(a=1, b="hello")

        Serialize parameters:

        >>> serialized_data = p.param.serialize_parameters()
        >>> print(serialized_data)
        {"name": "P00002", "a": 1, "b": "hello"}

        """
        ...
    
    def serialize_value(self_, pname, mode=...): # -> str:
        ...
    
    def deserialize_parameters(self_, serialization, subset=..., mode=...) -> dict:
        """
        Deserialize the given serialized data. This data can be used to create a
        `Parameterized` object or update the parameters of an existing `Parameterized` object.

        Parameters
        ----------
        serialization : str
            The serialized parameter data as a JSON string.
        subset : list of str, optional
            A list of parameter names to deserialize. If `None`, all parameters will be
            deserialized. Defaults to `None`.
        mode : str, optional
            The serialization format. By default, only 'json' is supported.
            Defaults to 'json'.

        Returns
        -------
        dict
            A dictionary with parameter names as keys and deserialized values.

        User Guide
        ----------
        https://param.holoviz.org/user_guide/Serialization_and_Persistence.html#serializing-with-json

        Examples
        --------
        >>> import param
        >>> class P(param.Parameterized):
        ...     a = param.Number()
        ...     b = param.String()
        ...
        >>> serialized_data = '{"a": 1, "b": "hello"}'
        >>> deserialized_data = P.param.deserialize_parameters(serialized_data)
        >>> print(deserialized_data)
        {'a': 1, 'b': 'hello'}
        >>> instance = P(**deserialized_data)

        """
        ...
    
    def deserialize_value(self_, pname, value, mode=...):
        ...
    
    def schema(self_, safe=..., subset=..., mode=...): # -> dict[Any, Any]:
        """Returns a schema for the parameters on this Parameterized object."""
        ...
    
    @_deprecated(extra_msg="""
        Use `.param.values().items()` instead (or `.param.values()` for the
        common case of `dict(....param.get_param_values())`)
    """, warning_cat=_ParamFutureWarning)
    def get_param_values(self_, onlychanged=...): # -> list[tuple[Any, Any]]:
        """
        Return a list of name,value pairs for all Parameters of this
        object.

        When called on an instance with onlychanged set to True, will
        only return values that are not equal to the default value
        (onlychanged has no effect when called on a class).

        .. deprecated:: 1.12.0
            Use `.param.values().items()` instead (or `.param.values()` for the
            common case of `dict(....param.get_param_values())`)
        """
        ...
    
    def values(self_, onlychanged=...): # -> dict[Any, Any]:
        """
        Return a dictionary of name,value pairs for the Parameters of this
        object.

        When called on an instance with onlychanged set to True, will
        only return values that are not equal to the default value
        (onlychanged has no effect when called on a class).
        """
        ...
    
    def force_new_dynamic_value(self_, name): # -> Any:
        """
        Force a new value to be generated for the dynamic attribute
        name, and return it.

        If name is not dynamic, its current value is returned
        (i.e. equivalent to getattr(name).
        """
        ...
    
    def get_value_generator(self_, name): # -> Any | list[Any]:
        """
        Return the value or value-generating object of the named
        attribute.

        For most parameters, this is simply the parameter's value
        (i.e. the same as getattr()), but Dynamic parameters have
        their value-generating object returned.
        """
        ...
    
    def inspect_value(self_, name): # -> Any | list[Any]:
        """
        Return the current value of the named attribute without modifying it.

        Same as getattr() except for Dynamic parameters, which have their
        last generated value returned.
        """
        ...
    
    def method_dependencies(self_, name, intermediate=...): # -> list[Any]:
        """
        Given the name of a method, returns a PInfo object for each dependency
        of this method. See help(PInfo) for the contents of these objects.

        By default intermediate dependencies on sub-objects are not
        returned as these are primarily useful for internal use to
        determine when a sub-object dependency has to be updated.
        """
        ...
    
    @_deprecated(extra_msg='Use instead `.param.method_dependencies`', warning_cat=_ParamFutureWarning)
    def params_depended_on(self_, *args, **kwargs): # -> list[Any]:
        """
        Given the name of a method, returns a PInfo object for each dependency
        of this method. See help(PInfo) for the contents of these objects.

        By default intermediate dependencies on sub-objects are not
        returned as these are primarily useful for internal use to
        determine when a sub-object dependency has to be updated.

        .. deprecated: 2.0.0
            Use instead `.param.method_dependencies`
        """
        ...
    
    def outputs(self_): # -> dict[Any, Any]:
        """
        Returns a mapping between any declared outputs and a tuple
        of the declared Parameter type, the output method, and the
        index into the output if multiple outputs are returned.
        """
        ...
    
    def watch(self_, fn, parameter_names, what=..., onlychanged=..., queued=..., precedence=...): # -> Watcher:
        """
        Register the given callback function `fn` to be invoked for
        events on the indicated parameters.

        `what`: What to watch on each parameter; either the value (by
        default) or else the indicated slot (e.g. 'constant').

        `onlychanged`: By default, only invokes the function when the
        watched item changes, but if `onlychanged=False` also invokes
        it when the `what` item is set to its current value again.

        `queued`: By default, additional watcher events generated
        inside the callback fn are dispatched immediately, effectively
        doing depth-first processing of Watcher events. However, in
        certain scenarios, it is helpful to wait to dispatch such
        downstream events until all events that triggered this watcher
        have been processed. In such cases setting `queued=True` on
        this Watcher will queue up new downstream events generated
        during `fn` until `fn` completes and all other watchers
        invoked by that same event have finished executing),
        effectively doing breadth-first processing of Watcher events.

        `precedence`: Declares a precedence level for the Watcher that
        determines the priority with which the callback is executed.
        Lower precedence levels are executed earlier. Negative
        precedences are reserved for internal Watchers, i.e. those
        set up by param.depends.

        When the `fn` is called, it will be provided the relevant
        Event objects as positional arguments, which allows it to
        determine which of the possible triggering events occurred.

        Returns a Watcher object.

        See help(Watcher) and help(Event) for the contents of those objects.
        """
        ...
    
    def unwatch(self_, watcher): # -> None:
        """Remove the given Watcher object (from `watch` or `watch_values`) from this object's list."""
        ...
    
    def watch_values(self_, fn, parameter_names, what=..., onlychanged=..., queued=..., precedence=...): # -> Watcher:
        """
        Easier-to-use version of `watch` specific to watching for changes in parameter values.

        Only allows `what` to be 'value', and invokes the callback `fn` using keyword
        arguments <param_name>=<new_value> rather than with a list of Event objects.
        """
        ...
    
    @_deprecated(extra_msg="Use instead `{k:v.default for k,v in p.param.objects().items()}`", warning_cat=_ParamFutureWarning)
    def defaults(self_): # -> dict[Any, Any]:
        """
        Return {parameter_name:parameter.default} for all non-constant
        Parameters.

        Note that a Parameter for which instantiate==True has its default
        instantiated.

        .. deprecated:: 1.12.0
            Use instead `{k:v.default for k,v in p.param.objects().items()}`
        """
        ...
    
    @_deprecated(extra_msg="""Use instead `for k,v in p.param.objects().items(): print(f"{p.__class__.name}.{k}={repr(v.default)}")`""", warning_cat=_ParamFutureWarning)
    def print_param_values(self_): # -> None:
        """
        Print the values of all this object's Parameters.

        .. deprecated:: 1.12.0
            Use instead `for k,v in p.param.objects().items(): print(f"{p.__class__.name}.{k}={repr(v.default)}")`
        """
        ...
    
    def warning(self_, msg, *args, **kw): # -> None:
        """
        Print msg merged with args as a warning, unless module variable
        warnings_as_exceptions is True, then raise an Exception
        containing the arguments.

        See Python's logging module for details of message formatting.
        """
        ...
    
    @_deprecated(extra_msg="Use instead `.param.log(param.MESSAGE, ...)`", warning_cat=_ParamFutureWarning)
    def message(self_, msg, *args, **kw): # -> None:
        """
        Print msg merged with args as a message.

        See Python's logging module for details of message formatting.

        .. deprecated:: 1.12.0
            Use instead `.param.log(param.MESSAGE, ...)`
        """
        ...
    
    @_deprecated(extra_msg="Use instead `.param.log(param.VERBOSE, ...)`", warning_cat=_ParamFutureWarning)
    def verbose(self_, msg, *args, **kw): # -> None:
        """
        Print msg merged with args as a verbose message.

        See Python's logging module for details of message formatting.

        .. deprecated:: 1.12.0
            Use instead `.param.log(param.VERBOSE, ...)`
        """
        ...
    
    @_deprecated(extra_msg="Use instead `.param.log(param.DEBUG, ...)`", warning_cat=_ParamFutureWarning)
    def debug(self_, msg, *args, **kw): # -> None:
        """
        Print msg merged with args as a debugging statement.

        See Python's logging module for details of message formatting.

        .. deprecated:: 1.12.0
            Use instead `.param.log(param.DEBUG, ...)`
        """
        ...
    
    def log(self_, level, msg, *args, **kw): # -> None:
        """
        Print msg merged with args as a message at the indicated logging level.

        Logging levels include those provided by the Python logging module
        plus VERBOSE, either obtained directly from the logging module like
        `logging.INFO`, or from parameterized like `param.parameterized.INFO`.

        Supported logging levels include (in order of severity)
        DEBUG, VERBOSE, INFO, WARNING, ERROR, CRITICAL

        See Python's logging module for details of message formatting.
        """
        ...
    
    def pprint(self_, imports=..., prefix=..., unknown_value=..., qualify=..., separator=...): # -> str:
        """
        (Experimental) Pretty printed representation that may be
        evaluated with eval. See pprint() function for more details.
        """
        ...
    


class ParameterizedMetaclass(type):
    """
    The metaclass of Parameterized (and all its descendents).

    The metaclass overrides type.__setattr__ to allow us to set
    Parameter values on classes without overwriting the attribute
    descriptor.  That is, for a Parameterized class of type X with a
    Parameter y, the user can type X.y=3, which sets the default value
    of Parameter y to be 3, rather than overwriting y with the
    constant value 3 (and thereby losing all other info about that
    Parameter, such as the doc string, bounds, etc.).

    The __init__ method is used when defining a Parameterized class,
    usually when the module where that class is located is imported
    for the first time.  That is, the __init__ in this metaclass
    initializes the *class* object, while the __init__ method defined
    in each Parameterized class is called for each new instance of
    that class.

    Additionally, a class can declare itself abstract by having an
    attribute __abstract set to True. The 'abstract' attribute can be
    used to find out if a class is abstract or not.
    """
    def __init__(mcs, name, bases, dict_) -> None:
        """
        Initialize the class object (not an instance of the class, but
        the class itself).

        Initializes all the Parameters by looking up appropriate
        default values (see __param_inheritance()) and setting
        attrib_names (see _set_names()).
        """
        ...
    
    __signature__ = ...
    abstract = ...
    param = ...
    def __setattr__(mcs, attribute_name, value): # -> None:
        """
        Implements 'self.attribute_name=value' in a way that also supports Parameters.

        If there is already a descriptor named attribute_name, and
        that descriptor is a Parameter, and the new value is *not* a
        Parameter, then call that Parameter's __set__ method with the
        specified value.

        In all other cases set the attribute normally (i.e. overwrite
        the descriptor).  If the new value is a Parameter, once it has
        been set we make sure that the value is inherited from
        Parameterized superclasses as described in __param_inheritance().
        """
        ...
    
    def get_param_descriptor(mcs, param_name): # -> tuple[Parameter, type] | tuple[None, None]:
        """
        Goes up the class hierarchy (starting from the current class)
        looking for a Parameter class attribute param_name. As soon as
        one is found as a class attribute, that Parameter is returned
        along with the class in which it is declared.
        """
        ...
    


script_repr_suppress_defaults = ...
def script_repr(val, imports=..., prefix=..., settings=..., qualify=..., unknown_value=..., separator=..., show_imports=...): # -> str | Any:
    """
    Variant of pprint() designed for generating a (nearly) runnable script.

    The output of script_repr(parameterized_obj) is meant to be a
    string suitable for running using `python file.py`. Not every
    object is guaranteed to have a runnable script_repr
    representation, but it is meant to be a good starting point for
    generating a Python script that (after minor edits) can be
    evaluated to get a newly initialized object similar to the one
    provided.

    The new object will only have the same parameter state, not the
    same internal (attribute) state; the script_repr captures only
    the state of the Parameters of that object and not any other
    attributes it may have.

    If show_imports is True (default), includes import statements
    for each of the modules required for the objects being
    instantiated. This list may not be complete, as it typically
    includes only the imports needed for the Parameterized object
    itself, not for values that may have been supplied to Parameters.

    Apart from show_imports, accepts the same arguments as pprint(),
    so see pprint() for explanations of the arguments accepted. The
    default values of each of these arguments differ from pprint() in
    ways that are more suitable for saving as a separate script than
    for e.g. pretty-printing at the Python prompt.
    """
    ...

def pprint(val, imports=..., prefix=..., settings=..., unknown_value=..., qualify=..., separator=...): # -> str | Any | None:
    """
    Pretty printed representation of a parameterized
    object that may be evaluated with eval.

    Similar to repr except introspection of the constructor (__init__)
    ensures a valid and succinct representation is generated.

    Only parameters are represented (whether specified as standard,
    positional, or keyword arguments). Parameters specified as
    positional arguments are always shown, followed by modified
    parameters specified as keyword arguments, sorted by precedence.

    unknown_value determines what to do where a representation cannot be
    generated for something required to recreate the object. Such things
    include non-parameter positional and keyword arguments, and certain
    values of parameters (e.g. some random state objects).

    Supplying an unknown_value of None causes unrepresentable things
    to be silently ignored. If unknown_value is a string, that
    string will appear in place of any unrepresentable things. If
    unknown_value is False, an Exception will be raised if an
    unrepresentable value is encountered.

    If supplied, imports should be a list, and it will be populated
    with the set of imports required for the object and all of its
    parameter values.

    If qualify is True, the class's path will be included (e.g. "a.b.C()"),
    otherwise only the class will appear ("C()").

    Parameters will be separated by a comma only by default, but the
    separator parameter allows an additional separator to be supplied
    (e.g. a newline could be supplied to have each Parameter appear on a
    separate line).

    Instances of types that require special handling can use the
    script_repr_reg dictionary. Using the type as a key, add a
    function that returns a suitable representation of instances of
    that type, and adds the required import statement. The repr of a
    parameter can be suppressed by returning None from the appropriate
    hook in script_repr_reg.
    """
    ...

script_repr_reg = ...
def container_script_repr(container, imports, prefix, settings): # -> LiteralString:
    ...

def function_script_repr(fn, imports, prefix, settings):
    ...

def type_script_repr(type_, imports, prefix, settings):
    ...

dbprint_prefix = ...
def truncate(str_, maxlen=...):
    """Return HTML-safe truncated version of given string"""
    ...

class _ClassPrivate:
    """
    parameters_state: dict
        Dict holding some transient states
    disable_instance_params: bool
        Whether to disable instance parameters
    renamed: bool
        Whethe the class has been renamed by a super class
    params: dict
        Dict of parameter_name:parameter
    """
    __slots__ = ...
    def __init__(self, parameters_state=..., disable_instance_params=..., explicit_no_refs=..., renamed=..., params=...) -> None:
        ...
    
    def __getstate__(self): # -> dict[str, Any]:
        ...
    
    def __setstate__(self, state): # -> None:
        ...
    


class _InstancePrivate:
    """
    initialized: bool
        Flag that can be tested to see if e.g. constant Parameters can still be set
    parameters_state: dict
        Dict holding some transient states
    dynamic_watchers: defaultdict
        Dynamic watchers
    ref_watchers: list[Watcher]
        Watchers used for internal references
    params: dict
        Dict of parameter_name:parameter
    refs: dict
        Dict of parameter name:reference
    watchers: dict
        Dict of dict:
            parameter_name:
                parameter_attribute (e.g. 'value'): list of `Watcher`s
    values: dict
        Dict of parameter name: value
    """
    __slots__ = ...
    def __init__(self, initialized=..., parameters_state=..., dynamic_watchers=..., refs=..., params=..., watchers=..., values=..., explicit_no_refs=...) -> None:
        ...
    
    def __getstate__(self): # -> dict[str, Any]:
        ...
    
    def __setstate__(self, state): # -> None:
        ...
    


class Parameterized(metaclass=ParameterizedMetaclass):
    """
    Base class for named objects that support Parameters and message
    formatting.

    Automatic object naming: Every Parameterized instance has a name
    parameter.  If the user doesn't designate a name=<str> argument
    when constructing the object, the object will be given a name
    consisting of its class name followed by a unique 5-digit number.

    Automatic parameter setting: The Parameterized __init__ method
    will automatically read the list of keyword parameters.  If any
    keyword matches the name of a Parameter (see Parameter class)
    defined in the object's class or any of its superclasses, that
    parameter in the instance will get the value given as a keyword
    argument.  For example:

    >>> class Foo(Parameterized):
    ...     xx = Parameter(default=1)

    >>> foo = Foo(xx=20)

    in this case foo.xx gets the value 20.

    When initializing a Parameterized instance ('foo' in the example
    above), the values of parameters can be supplied as keyword
    arguments to the constructor (using parametername=parametervalue);
    these values will override the class default values for this one
    instance.

    If no 'name' parameter is supplied, self.name defaults to the
    object's class name with a unique number appended to it.

    Message formatting: Each Parameterized instance has several
    methods for optionally printing output. This functionality is
    based on the standard Python 'logging' module; using the methods
    provided here, wraps calls to the 'logging' module's root logger
    and prepends each message with information about the instance
    from which the call was made. For more information on how to set
    the global logging level and change the default message prefix,
    see documentation for the 'logging' module.
    """
    name = ...
    def __init__(self, **params) -> None:
        ...
    
    @property
    def param(self): # -> Parameters:
        """
        The `.param` namespace for `Parameterized` classes and instances.

        This namespace provides access to powerful methods and properties for managing
        parameters in a `Parameterized` object. It includes utilities for adding parameters,
        updating parameters, debugging, serialization, logging, and more.

        User Guide
        ----------
        For more details on parameter objects and instances, see:
        https://param.holoviz.org/user_guide/Parameters.html#parameter-objects-and-instances

        Examples
        --------
        Basic usage of `.param` in a `Parameterized` class:

        >>> import param
        >>>
        >>> class MyClass(param.Parameterized):
        ...     value = param.Parameter()
        >>>
        >>> my_instance = MyClass(value=0)

        Access the `value` parameter of `my_instance`:

        >>> my_instance.param.value  # the Parameter instance

        Note that this is different from the current `value` of `my_instance`:

        >>> my_instance.value  # the current parameter value
        0

        """
        ...
    
    def __getstate__(self): # -> dict[str, Any]:
        """
        Save the object's state: return a dictionary that is a shallow
        copy of the object's __dict__ and that also includes the
        object's __slots__ (if it has any).
        """
        ...
    
    def __setstate__(self, state): # -> None:
        """
        Restore objects from the state dictionary to this object.

        During this process the object is considered uninitialized.
        """
        ...
    
    @_recursive_repr()
    def __repr__(self): # -> str:
        """
        Provide a nearly valid Python representation that could be used to recreate
        the item with its parameters, if executed in the appropriate environment.

        Returns 'classname(parameter1=x,parameter2=y,...)', listing
        all the parameters of this object.
        """
        ...
    
    def __str__(self) -> str:
        """Return a short representation of the name and class of this object."""
        ...
    


def print_all_param_defaults(): # -> None:
    """Print the default values for all imported Parameters."""
    ...

class ParamOverrides(dict):
    """
    A dictionary that returns the attribute of a specified object if
    that attribute is not present in itself.

    Used to override the parameters of an object.
    """
    def __init__(self, overridden, dict_, allow_extra_keywords=...) -> None:
        """

        If allow_extra_keywords is False, then all keys in the
        supplied dict_ must match parameter names on the overridden
        object (otherwise a warning will be printed).

        If allow_extra_keywords is True, then any items in the
        supplied dict_ that are not also parameters of the overridden
        object will be available via the extra_keywords() method.
        """
        ...
    
    def extra_keywords(self): # -> dict[Any, Any]:
        """
        Return a dictionary containing items from the originally
        supplied `dict_` whose names are not parameters of the
        overridden object.
        """
        ...
    
    def param_keywords(self): # -> dict[Any, Any]:
        """
        Return a dictionary containing items from the originally
        supplied `dict_` whose names are parameters of the
        overridden object (i.e. not extra keywords/parameters).
        """
        ...
    
    def __missing__(self, name): # -> Any:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __getattr__(self, name):
        ...
    
    def __setattr__(self, name, val): # -> None:
        ...
    
    def get(self, key, default=...): # -> None:
        ...
    
    def __contains__(self, key): # -> bool:
        ...
    


class ParameterizedFunction(Parameterized):
    """
    Acts like a Python function, but with arguments that are Parameters.

    Implemented as a subclass of Parameterized that, when instantiated,
    automatically invokes __call__ and returns the result, instead of
    returning an instance of the class.

    To obtain an instance of this class, call instance().
    """
    __abstract = ...
    def __str__(self) -> str:
        ...
    
    @bothmethod
    def instance(self_or_cls, **params): # -> <subclass of ParameterizedFunction* and ParameterizedMetaclass> | ParameterizedFunction:
        """
        Return an instance of this class, copying parameters from any
        existing instance provided.
        """
        ...
    
    def __new__(class_, *args, **params):
        ...
    
    def __call__(self, *args, **kw):
        ...
    
    def __reduce__(self): # -> tuple[Callable[..., Any], tuple[type[Self]], dict[str, Any]]:
        ...
    


class default_label_formatter(ParameterizedFunction):
    """Default formatter to turn parameter names into appropriate widget labels."""
    capitalize = ...
    replace_underscores = ...
    overrides = ...
    def __call__(self, pname): # -> Any:
        ...
    


label_formatter = default_label_formatter
class overridable_property:
    """
    The same as Python's "property" attribute, but allows the accessor
    methods to be overridden in subclasses.

    .. deprecated:: 2.0.0
    """
    def __init__(self, fget=..., fset=..., fdel=..., doc=...) -> None:
        ...
    
    def __get__(self, obj, objtype=...): # -> Self | Any:
        ...
    
    def __set__(self, obj, value): # -> None:
        ...
    
    def __delete__(self, obj): # -> None:
        ...
    


